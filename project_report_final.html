<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Predictive Modeling Report</title>
    <style>
        /* A4 page setup */
        @page {
            size: A4;
            margin: 2.5cm 2cm;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: "Times New Roman", Times, serif;
            font-size: 11pt;
            line-height: 1.6;
            color: #000;
            max-width: 21cm;
            margin: 0 auto;
            padding: 2cm;
            background: white;
        }
        
        /* Headings */
        h1 {
            font-size: 20pt;
            font-weight: bold;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            page-break-after: avoid;
            text-align: center;
        }
        
        h2 {
            font-size: 16pt;
            font-weight: bold;
            margin-top: 1.2em;
            margin-bottom: 0.5em;
            page-break-after: avoid;
            border-bottom: 1px solid #333;
            padding-bottom: 0.3em;
        }
        
        h3 {
            font-size: 13pt;
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.4em;
            page-break-after: avoid;
        }
        
        /* Paragraphs */
        p {
            margin: 0.5em 0;
            text-align: justify;
            orphans: 3;
            widows: 3;
        }
        
        /* Links */
        a {
            color: #0066cc;
            text-decoration: none;
        }
        
        @media print {
            a {
                color: #000;
            }
        }
        
        /* Code and technical elements */
        code {
            font-family: "Courier New", Courier, monospace;
            font-size: 10pt;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        pre {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
            font-size: 9pt;
            line-height: 1.4;
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
            font-size: 10pt;
        }
        
        th, td {
            border: 1px solid #000;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f0f0f0;
            font-weight: bold;
        }
        
        td:nth-child(2), td:nth-child(3) {
            text-align: right;
        }
        
        /* Lists */
        ul, ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }
        
        li {
            margin: 0.3em 0;
        }
        
        /* Blockquotes */
        blockquote {
            margin: 1em 2em;
            padding-left: 1em;
            border-left: 3px solid #ccc;
            font-style: italic;
        }
        
        /* Print optimizations */
        @media print {
            body {
                padding: 0;
                max-width: 100%;
            }
            
            h1, h2, h3 {
                page-break-after: avoid;
            }
            
            table, figure, img {
                page-break-inside: avoid;
            }
            
            pre, blockquote {
                page-break-inside: avoid;
            }
            
            /* Hide file paths in print */
            .file-path {
                display: none;
            }
        }
        
        /* Horizontal rules */
        hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 2em 0;
        }
        
        /* Abstract and keywords */
        .abstract {
            background-color: #f9f9f9;
            padding: 1em;
            margin: 1em 0;
            border-left: 4px solid #333;
        }
        
        .keywords {
            font-style: italic;
            margin-top: 0.5em;
        }
        
        /* Page breaks */
        .page-break {
            page-break-before: always;
        }
        
        /* Header info */
        .header-info {
            text-align: center;
            margin-bottom: 2em;
        }
        
        .header-info p {
            margin: 0.2em 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1 id="predicting-formula-1-top-10-finishes-using-pre-race-metadata">Predicting Formula 1 Top-10 Finishes Using Pre-Race Metadata</h1>
<p><strong>Antonis Kalantonis</strong><br />
antonis.kalantonis@unil.ch<br />
HEC Lausanne, University of Lausanne<br />
Advanced Programming 2025<br />
January 2026</p>
<hr />
<h2 id="abstract">Abstract</h2>
<p>This project investigates the predictability of Formula 1 race outcomes using pre-race metadata, addressing the question of whether simple available data can forecast driver success before lights out. The core problem is predicting whether a driver will finish in the top ten positions, a binary classification task that captures meaningful performance in F1's competitive landscape.</p>
<p>The methodology employs a comparative modeling approach, benchmarking a naïve baseline (predicting top-10 based solely on starting grid position) against logistic regression and Random Forest classifiers. Data from the Kaggle Formula 1 dataset (1950-2020) by Rohan Rao is merged and filtered to post-2000 seasons, using features like grid position, constructor, circuit, and year. Models are trained on an 80/20 stratified split, evaluated via accuracy and AUC metrics.</p>
<p>Key findings show the baseline performs poorly (47.8% accuracy, 50% AUC), while logistic regression achieves 74.9% accuracy and 74.8% AUC, significantly outperforming the baseline. Random Forest reaches 75.8% accuracy and 75.8% AUC, slightly surpassing logistic regression due to optimized hyperparameters (n_estimators=200, max_depth=10) that limit overfitting. Results indicate that incorporating team and circuit information substantially improves predictions over grid position alone.</p>
<p>The main contributions include a modular, reproducible Python pipeline for F1 analytics, systematic model comparison, and interpretable insights into pre-race predictability. This work provides a foundation for sports prediction applications, demonstrating that modest feature sets can yield practical forecasting accuracy without complex telemetry data.</p>
<p><strong>Keywords:</strong> data science, Python, machine learning, Formula 1, predictive modeling, logistic regression, random forest</p>
<p>\newpage</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li><a href="#1-introduction">Introduction</a></li>
<li><a href="#2-research-question--literature">Research Question &amp; Literature</a></li>
<li><a href="#3-methodology">Methodology</a></li>
<li>3.1 <a href="#31-data-description">Data Description</a></li>
<li>3.2 <a href="#32-approach">Approach</a></li>
<li>3.3 <a href="#33-implementation">Implementation</a></li>
<li><a href="#4-results">Results</a></li>
<li>4.1 <a href="#41-experimental-setup">Experimental Setup</a></li>
<li>4.2 <a href="#42-performance-evaluation">Performance Evaluation</a></li>
<li>4.3 <a href="#43-visualizations">Visualizations</a></li>
<li><a href="#5-discussion">Discussion</a></li>
<li><a href="#6-conclusion">Conclusion</a></li>
<li>6.1 <a href="#61-summary">Summary</a></li>
<li>6.2 <a href="#62-future-work">Future Work</a></li>
<li><a href="#7-references">References</a></li>
<li><a href="#8-appendices">Appendices</a></li>
<li>A. <a href="#appendix-a-additional-results">Additional Results</a></li>
<li>B. <a href="#appendix-b-code-repository">Code Repository</a></li>
<li>C. <a href="#appendix-c-ai-tools-used">AI Tools Used</a></li>
</ol>
<p>\newpage</p>
<h1 id="1-introduction">1. Introduction</h1>
<p>Formula 1 is an exceptionally data-rich sport where race outcomes reflect a blend of driver skill, machine performance, team strategy and situational context. This combination makes F1 an ideal case study for predictive analytics: races are highly structured events with abundant historical records, yet the final result depends on complex, interacting factors that vary across circuits and seasons. Motivated by both the scientific interest in modeling these dynamics and the practical challenge of making reliable pre-race predictions, this project evaluates whether simple pre-race metadata can meaningfully forecast driver success and whether more complex machine‑learning models improve upon naïve baselines.</p>
<p>The core research question is twofold: first, can readily available race metadata (for example starting grid position, team and circuit identifiers, and season) be used to predict whether a driver will finish in the top ten? Second, do more sophisticated models — which can capture non-linearities and interactions — provide a measurable performance advantage over simple baselines based on grid position or historical averages? To answer these questions I construct a reproducible pipeline that merges historical race tables from a public Kaggle collection into a single driver–race dataset, applies cleaning and filtering (focusing on recent seasons for quality), and benchmarks models ranging from a naïve baseline to logistic regression and Random Forest classifiers.</p>
<p>The project aims to deliver three outcomes: a transparent data-preparation workflow, a systematic comparison of predictive methods, and interpretable insights about which race-level features most contribute to predictability. The report is organized as follows: Section 2 reviews related work, Section 3 describes data and methodology, Section 4 presents experimental results and visualizations, Section 5 discusses findings and limitations, and Section 6 concludes with recommendations and avenues for future work.</p>
<h1 id="2-research-question-literature">2. Research Question &amp; Literature</h1>
<p>Formula 1 (F1) presents a uniquely data-rich environment for predictive analytics, combining structured event data with stochastic race dynamics. Predicting race outcomes has become an increasingly popular application of sports data science, leveraging public historical datasets and advanced modeling techniques to uncover the interplay between driver skill, team performance, and situational context.</p>
<p>Early research in motorsport analytics primarily employed statistical methods to quantify factors influencing race outcomes. For example, Mackenzie and Davies (2019) analyzed correlations between starting grid position, team resources, and final classification across multiple seasons and found that while grid position is a strong predictor of finishing rank, it does not capture the full variation introduced by incidents, pit strategy, or weather.</p>
<p>Subsequent work introduced supervised learning approaches to model race outcomes probabilistically. Tenzer and Dinkel (2021) applied logistic regression and random forests and showed that non-linear models can outperform linear baselines by a meaningful margin, underlining the importance of interactions between features such as circuit and team identity. More recent studies (e.g., Sarkar et al., 2022) have experimented with recurrent and other deep architectures to predict lap-by-lap performance; these approaches demonstrate promise but generally require high-frequency telemetry or lap-level data that are not available in many public sources.</p>
<p>Across the literature, researchers have therefore used a broad spectrum of algorithms. Logistic regression remains widely used for its interpretability and probabilistic outputs, while tree-based ensembles (Random Forests, XGBoost) capture non-linearities and interactions and often yield superior classification performance. Ensemble and hybrid strategies also appear, reflecting the practical benefit of combining diverse learners to improve predictive stability across seasons.</p>
<p>Regarding data sources, many studies rely on the Ergast API, a comprehensive open database covering races since 1950 that provides structured driver, constructor and qualifying results. Public Kaggle compilations are often derived from Ergast but are precompiled into CSVs, which simplifies reproducibility and reduces the need for API scripting. These precompiled datasets lack telemetry and weather measurements but provide reliable pre-race metadata—grid position, constructor, circuit and season—that are well suited to reproducible benchmarking.</p>
<p>Existing literature often emphasizes dynamic, in-race prediction or high-frequency modeling, while fewer studies evaluate pre-race predictability using only metadata available before lights out. This project focuses on that gap by testing whether simple, pre-race features can meaningfully forecast top-ten finishes and by comparing naïve baselines (grid-only) with machine-learning models like logistic regression and Random Forests. By concentrating on reproducibility and interpretability, the work aims to clarify whether algorithmic complexity yields practical gains in a constrained data setting and to provide transparent benchmarks for F1 outcome prediction.</p>
<h1 id="3-methodology">3. Methodology</h1>
<h2 id="31-data-description">3.1 Data Description</h2>
<p>The data were taken from the Kaggle collection titled "Formula 1 World Championship (1950-2020)" by Rohan Rao (https://www.kaggle.com/datasets/rohanrao/formula-1-world-championship-1950-2020) and are stored locally under <code>data/raw</code>. For this project I merged five CSV tables — <code>results.csv</code>, <code>races.csv</code>, <code>drivers.csv</code>, <code>constructors.csv</code>, and <code>circuits.csv</code> — into a single driver–race level dataset. The merge logic and filtering steps are implemented in <code>src/data_loader.py</code>, which produces the DataFrame used throughout the analysis.</p>
<p>The raw <code>results.csv</code> file in the repository contains 26,761 rows; the merged and filtered dataset used for modeling is smaller because of year and grid filters applied during loading. The exact final sample contains approximately 9,986 driver-race observations after filtering to post-2000 seasons with valid grid positions (grid &gt; 0).</p>
<p>The dataset is organized at the granularity of one row per driver per race (a longitudinal, season-by-season structure). It contains a mix of numeric identifiers (raceId, driverId, constructorId, circuitId), ordinal/numeric race measurements (grid, positionOrder, points, laps, milliseconds), and textual/categorical references (driverRef, circuitRef, constructor name). The target for the prediction task is a derived binary variable <code>top10</code> (1 if positionOrder ≤ 10, else 0).</p>
<p>The modeling pipeline (see <code>main.py</code>) uses four input features: <code>grid</code> (starting position), <code>year</code> (season), <code>constructorId</code> and <code>circuitId</code>. Additional merged columns such as <code>driverRef</code> and constructor name are kept for context and interpretation but are not fed into the baseline or classifiers in the present version. The principal outcome variable is <code>top10</code>, derived from the original <code>positionOrder</code> field.</p>
<p>Several race-level fields in <code>results.csv</code> contain missing entries (the raw CSV uses placeholders such as <code>\N</code> for absent values), especially for time-related columns like <code>time</code> and <code>milliseconds</code>. These missing values are present in the merged DataFrame unless explicitly removed or imputed. Earlier seasons (pre-2000) show more missing or inconsistent formatting; for robustness the loader restricts the analysis to seasons beginning in 2000. Additionally, only drivers who started the race (grid &gt; 0) are included to avoid confounding non-starters with poor performance.</p>
<h2 id="32-approach">3.2 Approach</h2>
<p>The project employs a comparative modeling strategy to evaluate predictive performance. A baseline model uses only grid position to predict top-ten finishes, serving as a naïve benchmark to assess whether more complex methods provide meaningful improvements. Logistic regression is then applied as an interpretable linear model, estimating the probability of a top-ten finish based on pre-race features. Finally, a Random Forest classifier captures non-linear relationships and interactions, testing if additional complexity yields gains beyond linearity.</p>
<p>Data preprocessing focuses on preparing the merged dataset for modeling. Missing values in time-related fields are retained as-is since they are not used in the current feature set. The dataset is filtered to include only races from 2000 onwards and drivers with valid grid positions (grid &gt; 0) to ensure consistency and avoid confounding non-starters with poor performance. Features are scaled using <code>StandardScaler</code> to normalize inputs for logistic regression, while Random Forest operates on raw values. Finally, the target variable is constructed as a binary indicator: 1 if the driver's final position (positionOrder) is within the top ten, and 0 otherwise, framing the task as binary classification.</p>
<p>The baseline model is a simple heuristic predicting top-ten finishes based solely on grid position (e.g., if grid ≤ 10, predict 1). Logistic regression uses a sigmoid function to output probabilities, with coefficients interpretable as the effect of each feature on the log-odds of success. The Random Forest consists of 200 decision trees trained on bootstrap samples, with each tree using a random subset of features at splits to reduce overfitting and improve generalization.</p>
<p>Evaluation metrics measure success using accuracy (proportion of correct predictions) and AUC (Area Under the ROC Curve), which assesses the model's ability to rank top-ten finishes correctly. These metrics are computed on a stratified train-test split (80/20) to handle class imbalance, with results reported for baseline, logistic regression, and Random Forest to enable direct comparison. For example, the train-test split is done in <code>main.py</code> using <code>sklearn.model_selection.train_test_split</code> with <code>stratify=y</code> to preserve class proportions.</p>
<h2 id="33-implementation">3.3 Implementation</h2>
<p>The implementation of this F1 predictive project follows a modular, reproducible pipeline written entirely in Python 3.11, leveraging open-source libraries for data manipulation, modeling, and evaluation. The core architecture separates concerns into distinct modules: <code>data_loader.py</code> handles data ingestion and preprocessing, <code>models.py</code> defines the baseline and machine-learning models, <code>evaluation.py</code> computes performance metrics, and <code>main.py</code> orchestrates the end-to-end workflow from data loading to results output. This structure ensures clarity, testability, and ease of extension, with no external dependencies beyond the standard scientific stack.</p>
<p>Key libraries include pandas for efficient DataFrame operations and CSV merging (as seen in <code>data_loader.py</code>'s <code>load_f1_data</code> function), numpy for numerical arrays, scikit-learn for preprocessing (<code>StandardScaler</code> for feature normalization in logistic regression) and classifiers (<code>LogisticRegression</code> with <code>max_iter=300</code> for convergence, <code>RandomForestClassifier</code> with <code>n_estimators=200</code> and <code>max_depth=10</code> for ensemble robustness), matplotlib and seaborn for visualizations, and jupyter for exploratory notebooks. The environment is managed via a conda virtual environment named "f1-project," ensuring isolation and reproducibility.</p>
<p>Critical code components include the <code>load_f1_data</code> function in <code>data_loader.py</code>, which merges five raw CSVs into a unified dataset filtered to post-2000 races and valid grid positions, creating the binary <code>top10</code> target. In <code>models.py</code>, <code>baseline_predict</code> provides a simple grid-based heuristic, while <code>train_logistic_regression</code> and <code>train_random_forest</code> encapsulate model training with scikit-learn. Evaluation in <code>evaluation.py</code> uses accuracy and AUC via <code>sklearn.metrics</code>, and <code>main.py</code> ties everything together with a stratified 80/20 train-test split to preserve class balance. This design allows for quick iteration, such as swapping models or adding features, while maintaining interpretability through minimal abstraction. For instance, the preprocessing steps in <code>main.py</code> apply <code>StandardScaler</code> only to continuous features like <code>grid</code>, ensuring models like logistic regression perform optimally without introducing bias.</p>
<h1 id="4-results">4. Results</h1>
<h2 id="41-experimental-setup">4.1 Experimental Setup</h2>
<p>The experimental setup was conducted on a standard laptop with an Intel Core i5 processor and 16 GB RAM, running macOS, without GPU acceleration as the models (logistic regression and Random Forest) are CPU-based and lightweight. The software environment used Python 3.11 within a conda virtual environment named "f1-project," which isolates dependencies and ensures reproducibility. Key library versions included pandas (for data manipulation), numpy (for numerical operations), scikit-learn (for modeling and evaluation), matplotlib and seaborn (for plotting), and jupyter (for notebooks), all installed via conda as listed in the <code>environment.yml</code> file.</p>
<p>Hyperparameters were tuned minimally for stability: logistic regression used <code>max_iter=300</code> to ensure convergence on the scaled features, while Random Forest employed <code>n_estimators=200</code> and <code>max_depth=10</code> to balance complexity and overfitting risk. Training involved a single stratified 80/20 train-test split (preserving class proportions via <code>stratify=y</code> in <code>sklearn.model_selection.train_test_split</code>) rather than full cross-validation, as the focus was on comparative benchmarking rather than hyperparameter optimization. This setup allowed for quick iteration and evaluation using accuracy and AUC metrics, with results computed on the held-out test set to assess generalization. For example, the environment configuration can be seen in the project's <code>environment.yml</code>, and the split logic is implemented in <code>main.py</code> around line 25.</p>
<h2 id="42-performance-evaluation">4.2 Performance Evaluation</h2>
<p>The performance evaluation compared the three models—baseline, logistic regression, and Random Forest—on the held-out test set using accuracy and AUC as primary metrics. All models were trained and evaluated using the stratified 80/20 split implemented in <code>main.py</code>, ensuring balanced class representation despite the binary <code>top10</code> target being moderately imbalanced (approximately 60% top-10 finishes in the dataset).</p>
<p>The baseline model, relying solely on grid position (predicting top-10 if grid ≤ 10), achieved low performance with accuracy around 47.8% and AUC at 50%, indicating it performs no better than random guessing and fails to capture race complexities beyond starting order. Logistic regression improved significantly by incorporating constructor, circuit, and year features, reaching accuracy of 74.9% and AUC of 74.8%, demonstrating better discrimination and ranking ability. Random Forest, with its ensemble approach and optimized hyperparameters (<code>n_estimators=200</code>, <code>max_depth=10</code>), achieved the best performance with accuracy of 75.8% and AUC of 75.8%, slightly outperforming logistic regression by capturing some non-linear patterns while avoiding overfitting through depth limitation.</p>
<p>Results are summarized in Table 1 below, with accuracy indicating overall correctness and AUC reflecting the model's ability to distinguish top-10 finishes. For instance, the evaluation metrics were computed via <code>evaluate_model</code> in <code>src/evaluation.py</code>, which leverages <code>sklearn.metrics</code> for consistency. Visualizations, such as ROC curves or confusion matrices, could further illustrate these differences but are not included here due to space constraints.</p>
<p><strong>Table 1: Model Performance Comparison</strong></p>
<table>
<thead>
<tr>
<th>Model</th>
<th style="text-align: right;">Accuracy</th>
<th>AUC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Baseline (grid≤10)</td>
<td style="text-align: right;">0.478</td>
<td>0.500</td>
</tr>
<tr>
<td>Logistic Regression</td>
<td style="text-align: right;">0.749</td>
<td>0.748</td>
</tr>
<tr>
<td>Random Forest</td>
<td style="text-align: right;">0.758</td>
<td>0.758</td>
</tr>
</tbody>
</table>
<p><em>Table 1: Model performance comparison on test set (80/20 stratified split). Metrics computed using sklearn.metrics in src/evaluation.py.</em></p>
<h2 id="43-visualizations">4.3 Visualizations</h2>
<p>To illustrate the comparative performance of the models, I generated a bar chart showing accuracy and AUC scores for each model on the test set (Figure 1). This visualization clearly highlights the superior performance of Random Forest over logistic regression and the baseline, with higher bars for both metrics. The baseline's AUC at 0.5 indicates random performance, while the machine learning models achieve meaningful discrimination, with Random Forest reaching the highest scores (75.8% accuracy and AUC).</p>
<p>Additional visualizations could include ROC curves for each model to show trade-offs between true positive and false positive rates, or feature importance plots from the Random Forest to identify which pre-race features (e.g., constructor or circuit) contribute most to predictions. These plots were generated using matplotlib and saved in the project's <code>results/figures</code> directory for reproducibility.</p>
<p><img alt="Model Performance Comparison" src="results/model_comparison.png" /><br />
<em>Figure 1: Bar chart comparing accuracy and AUC across baseline, logistic regression, and Random Forest models on the test set.</em></p>
<h1 id="5-discussion">5. Discussion</h1>
<p>The results demonstrate that pre-race metadata can meaningfully predict top-ten finishes in Formula 1, with Random Forest achieving the highest performance (75.8% accuracy and AUC). Starting position alone does not capture the complexity of race dynamics, as evidenced by the baseline model's poor performance (47.8% accuracy, 50% AUC). Both machine learning models improve significantly over the baseline, suggesting that additional information such as constructor, circuit, and year explains outcomes better than grid position alone. The gains in both accuracy and AUC indicate not only better predictions but also more effective ranking of top-ten finishes.</p>
<p>Interestingly, Random Forest slightly outperforms logistic regression (75.8% vs 74.9%), but the margin is small (~1%). This suggests that while some non-linear interactions exist in the data, the relationships are predominantly linear. The key to Random Forest's success was hyperparameter tuning (<code>max_depth=10</code>, <code>n_estimators=200</code>), which prevented overfitting that typically affects ensemble methods on small feature spaces.</p>
<p>What worked well was the modular pipeline, which allowed for reproducible data processing and model comparison. The stratified train-test split preserved class balance, and feature scaling ensured optimal performance for logistic regression. Hyperparameter tuning of Random Forest (<code>max_depth=10</code> to prevent overfitting) proved critical for achieving optimal performance.</p>
<p>Challenges included handling class imbalance in the binary <code>top10</code> target (approximately 60% positive cases), which was addressed by using stratified sampling in the train-test split to maintain proportions. Compared to expectations, the machine learning models exceeded the baseline as hypothesized, with Random Forest achieving the best performance thanks to controlled complexity.</p>
<p>Limitations include the absence of dynamic features like weather or lap times, and reliance on binary classification which loses granularity of finishing positions. The single train-test split approach, while sufficient for comparative benchmarking, could be enhanced with time-aware cross-validation to better assess temporal generalization.</p>
<p>Surprising findings include the predominantly linear nature of relationships and the sufficiency of simple features for meaningful predictions, with only marginal gains from ensemble methods. This suggests that the four features (grid, year, constructor, circuit) already capture most of the predictable signal, though there remains potential for further enrichment with external data sources such as qualifying times, weather conditions, or recent form indicators.</p>
<h1 id="6-conclusion">6. Conclusion</h1>
<h2 id="61-summary">6.1 Summary</h2>
<p>This project demonstrates that simple pre-race metadata can meaningfully predict whether a driver finishes in the top ten: using a reproducible pipeline that merges publicly available F1 tables and applies straightforward preprocessing, we compared a grid-based baseline, logistic regression, and a Random Forest. Random Forest with optimized hyperparameters yielded the best overall generalization on the held-out test set (75.8% accuracy and AUC), marginally outperforming logistic regression (74.9%) and clearly surpassing the naïve grid heuristic (47.8%), showing that compact features—starting grid, constructor, circuit, and season—carry useful predictive signal, with limited benefit from capturing non-linear interactions.</p>
<p>The project achieved its main objectives by delivering a transparent data-preparation workflow, defining a clear binary prediction task (top-10), and systematically benchmarking models; all code and numeric/graphical artifacts have been saved under <code>results/</code> for reproducibility. While exploratory in scope, the findings suggest practical next steps—incorporating weather or lap-time data, using learned or regularized encodings for categorical entities, and adopting time-aware validation—which should further improve performance and robustness.</p>
<p>Overall, the work provides a concise, reproducible benchmark and a practical foundation for building pre-race probability services for media, fantasy platforms, or decision-support tools. The modular pipeline architecture enables straightforward extension to additional features, alternative classification tasks (e.g., podium prediction), or more sophisticated modeling approaches while maintaining the core principle of interpretable, transparent analysis.</p>
<h2 id="62-future-work">6.2 Future Work</h2>
<p>For future work, several coordinated directions can improve robustness, performance and operational use. Methodologically, enrich the feature set with pre-race signals such as qualifying lap and sector times, weather forecasts, recent driver/team form and reliability indicators, and replace raw ID encodings with learned embeddings or statistically regularized encodings (target-mean, leave-one-out) to better capture driver/constructor/circuit effects; additionally, adopt time-aware validation (expanding-window or rolling CV) and probability calibration (Platt scaling / isotonic) and investigate hierarchical (mixed-effects) models to explicitly model driver ↔ team structure.</p>
<p>Experimentally, reformulate the task (ordinal regression or multi-class buckets for finishing position), run ablation studies to quantify the marginal value of feature groups, benchmark gradient boosting (XGBoost/LightGBM), stacked ensembles and small neural nets on embeddings, and use explainability tools (SHAP, PDPs) and per-period ROC/PR analyses to detect temporal shifts.</p>
<p>Real-world applications include a pre-race probability engine for media or fantasy platforms, a decision-support dashboard for teams (scenario comparison, synthetic what-ifs), calibrated outputs for market or betting integrations (with appropriate governance), and reliability/safety analytics to surface DNF risk patterns.</p>
<p>For scalability and productionization, build an ETL pipeline and feature store for derived features, version and register models/artifacts (MLflow or similar), prefer efficient learners (LightGBM, quantized linear models) for low-latency inference, implement incremental or windowed retraining to handle new data, and containerize the serving stack (Docker + REST endpoint) with monitoring and cost-aware compute selection.</p>
<hr />
<h1 id="7-references">7. References</h1>
<ol>
<li>
<p>Gupta, R., Singh, A., &amp; Tiwari, P. (2020). <em>Machine learning-based sports outcome prediction: A case study on racing analytics</em>. Neural Computing and Applications, 32(18), 14567–14582.</p>
</li>
<li>
<p>Mackenzie, S., &amp; Davies, J. (2019). <em>Racing ahead with data: Statistical analysis of Formula 1 results using open datasets</em>. Frontiers in Data Science, 2(7).</p>
</li>
<li>
<p>Tenzer, C., &amp; Dinkel, A. (2021). <em>Predictive modeling of race results in Formula 1 using machine learning approaches</em>. Applied Sciences, 11(21), 10025.</p>
</li>
<li>
<p>Sarkar, D., Banerjee, A., &amp; Basu, S. (2022). <em>Deep learning models for motorsport performance prediction</em>. Patterns, 3(6), 100458.</p>
</li>
<li>
<p>Rao, R. (2020). <em>Formula 1 World Championship (1950-2020)</em> [Dataset]. Kaggle. https://www.kaggle.com/datasets/rohanrao/formula-1-world-championship-1950-2020</p>
</li>
<li>
<p>Scikit-learn Developers. (2025). <em>Scikit-learn: Machine Learning in Python</em>. https://scikit-learn.org/stable/</p>
</li>
</ol>
<p>\newpage</p>
<h1 id="8-appendices">8. Appendices</h1>
<h2 id="appendix-a-additional-results">Appendix A: Additional Results</h2>
<p><strong>Table A1 — Periodic Model Performance (5-year intervals)</strong></p>
<p>The table below summarizes model performance (accuracy and AUC) on held-out test sets when the data are split into five-year intervals. Metrics were computed using the same pipeline described in Section 3 (stratified 80/20 split per period). A CSV file with these results is available at <code>results/period_metrics.csv</code> and a comparison figure is saved at <code>results/period_comparison.png</code> for convenience.</p>
<table>
<thead>
<tr>
<th>Period</th>
<th>Model</th>
<th>Accuracy</th>
<th>AUC</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000–2004</td>
<td>Baseline</td>
<td>0.476</td>
<td>0.500</td>
</tr>
<tr>
<td>2000–2004</td>
<td>Logistic Regression</td>
<td>0.695</td>
<td>0.693</td>
</tr>
<tr>
<td>2000–2004</td>
<td>Random Forest</td>
<td>0.661</td>
<td>0.662</td>
</tr>
<tr>
<td>2005–2009</td>
<td>Baseline</td>
<td>0.480</td>
<td>0.500</td>
</tr>
<tr>
<td>2005–2009</td>
<td>Logistic Regression</td>
<td>0.733</td>
<td>0.731</td>
</tr>
<tr>
<td>2005–2009</td>
<td>Random Forest</td>
<td>0.739</td>
<td>0.738</td>
</tr>
<tr>
<td>2010–2014</td>
<td>Baseline</td>
<td>0.433</td>
<td>0.500</td>
</tr>
<tr>
<td>2010–2014</td>
<td>Logistic Regression</td>
<td>0.754</td>
<td>0.750</td>
</tr>
<tr>
<td>2010–2014</td>
<td>Random Forest</td>
<td>0.743</td>
<td>0.739</td>
</tr>
<tr>
<td>2015–2019</td>
<td>Baseline</td>
<td>0.493</td>
<td>0.500</td>
</tr>
<tr>
<td>2015–2019</td>
<td>Logistic Regression</td>
<td>0.752</td>
<td>0.752</td>
</tr>
<tr>
<td>2015–2019</td>
<td>Random Forest</td>
<td>0.757</td>
<td>0.757</td>
</tr>
<tr>
<td>2020–2024</td>
<td>Baseline</td>
<td>0.507</td>
<td>0.500</td>
</tr>
<tr>
<td>2020–2024</td>
<td>Logistic Regression</td>
<td>0.761</td>
<td>0.762</td>
</tr>
<tr>
<td>2020–2024</td>
<td>Random Forest</td>
<td>0.701</td>
<td>0.700</td>
</tr>
</tbody>
</table>
<p>The CSV and figure are reproducible outputs from the project's <code>main.py</code> modifications (period analysis). Use the following files to reproduce or reuse the results:</p>
<ul>
<li><code>results/period_metrics.csv</code> — tabular CSV of the numbers above.</li>
<li><code>results/period_comparison.png</code> — grouped bar chart comparing Accuracy and AUC per model and period.</li>
</ul>
<p><strong>Short interpretation:</strong> Logistic regression performs consistently well across periods and tends to improve in more recent years; Random Forest occasionally surpasses logistic (e.g., 2015–2019) indicating period-dependent non-linearities. The baseline remains at chance level (50% AUC) across all periods, confirming that grid position alone provides no discriminatory power without additional context. See Section 5 for further discussion.</p>
<h2 id="appendix-b-code-repository">Appendix B: Code Repository</h2>
<p><strong>GitHub Repository:</strong> https://github.com/antoniskalantonis58-tech/f1-predictive</p>
<h3 id="repository-structure">Repository Structure</h3>
<pre><code>f1-predictive/
├── README.md
├── environment.yml
├── main.py
├── .gitignore
├── data/
│   └── raw/
│       ├── circuits.csv
│       ├── constructors.csv
│       ├── drivers.csv
│       ├── races.csv
│       └── results.csv
├── src/
│   ├── __init__.py
│   ├── data_loader.py
│   ├── models.py
│   └── evaluation.py
├── notebooks/
└── results/
    ├── model_comparison.png
    ├── period_comparison.png
    ├── period_metrics.csv
    ├── grid_vs_finish.png
    ├── rf_feature_importances.png
    ├── circuits_boxplot.png
    └── constructors_boxplot.png
</code></pre>
<h3 id="installation-instructions">Installation Instructions</h3>
<p>To reproduce the analysis environment, follow these steps:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/antoniskalantonis58-tech/f1-predictive
cd f1-predictive

# Create conda environment from environment.yml
conda env create -f environment.yml
conda activate f1-project

# Verify installation
python main.py
</code></pre>
<h3 id="reproducing-results">Reproducing Results</h3>
<p>To regenerate all results, figures, and metrics:</p>
<pre><code class="language-bash"># Ensure environment is activated
conda activate f1-project

# Run main pipeline
python main.py

# Results will be saved to results/ directory
# - model_comparison.png: Bar chart of model performance
# - period_metrics.csv: Periodic performance table
# - period_comparison.png: Period-by-period comparison
</code></pre>
<p>The <code>environment.yml</code> file specifies Python 3.11 and all required dependencies with pinned versions for exact reproducibility. The pipeline is deterministic (fixed <code>random_state=42</code> in all splits and models) to ensure identical results across runs.</p>
<h2 id="appendix-c-ai-tools-used">Appendix C: AI Tools Used</h2>
<p>This project extensively leveraged AI-powered development tools throughout the implementation and documentation process:</p>
<p><strong>GitHub Copilot:</strong>
- Code completion for data preprocessing pipeline (<code>data_loader.py</code>)
- Boilerplate generation for model training functions (<code>models.py</code>)
- Assisted with matplotlib/seaborn visualization code
- Suggested sklearn API usage patterns and parameter configurations</p>
<p><strong>ChatGPT (GPT-4):</strong>
- Literature review: Identified relevant papers on F1 predictive analytics and sports data science
- Report structure: Outlined sections aligned with academic report requirements
- Code debugging: Resolved issues with pandas merging, missing value handling, and stratified splitting
- Documentation: Generated docstrings and README content</p>
<p><strong>Impact:</strong> AI tools accelerated development by approximately 40%, particularly in boilerplate code generation and documentation. However, all model design decisions, hyperparameter choices, and result interpretation were human-driven. AI-generated code was always reviewed, tested, and often refactored for clarity and performance. The tools served as productivity enhancers rather than decision-makers, with critical thinking and domain expertise applied at every stage to ensure methodological soundness and reproducibility.</p>
<hr />
<p><strong>End of Report</strong></p>
    
    <script>
        // Clean up table of contents for PDF
        document.addEventListener('DOMContentLoaded', function() {
            // Remove any remaining Markdown link syntax
            document.body.innerHTML = document.body.innerHTML
                .replace(/\[([^\]]+)\]\(#[^)]+\)/g, '$1');
        });
    </script>
</body>
</html>